# Практическое руководство для защиты: Демонстрация работы

---

### Общее вступление

**Что говорить:**
«Здравствуйте! Сегодня я продемонстрирую результаты своей практической работы по DevOps. Я покажу, как настроил автоматизированный конвейер для сборки, тестирования и доставки программного обеспечения. Моя работа состоит из трех частей: непрерывная интеграция, доставка с помощью Docker и создание повторно используемого шаблона для стандартизации этих процессов».

--- 

## Часть 1: Непрерывная интеграция (CI)

**Цель:** Показать, как тесты запускаются автоматически, чтобы ловить ошибки на ранней стадии.

### Шаг 1: Показываем код и тесты

**Что делать:**
1.  Откройте папку `python-ci-lab`.
2.  Откройте файл `src/calculator.py`.

**Что говорить:**
«Начнем с первого задания. Здесь у нас простой Python-проект — калькулятор с несколькими функциями: сложение, умножение и так далее. Это наша "бизнес-логика"».

**Что делать:**
1.  Теперь откройте файл `tests/test_calculator.py`.

**Что говорить:**
«А это — тесты для нашего калькулятора. Для каждой функции написано несколько проверок, чтобы убедиться, что она работает правильно. Например, мы проверяем сложение положительных чисел, отрицательных и так далее. Всего у нас 16 тестов».

### Шаг 2: Запускаем тесты локально

**Что делать:**
1.  Откройте терминал в папке `python-ci-lab`.
2.  Выполните команду:
    ```bash
    pytest tests/ -v --cov=src
    ```

**Что говорить:**
«Перед тем, как что-то автоматизировать, давайте убедимся, что тесты работают локально. Я запускаю `pytest`, и мы видим результат: **16 тестов успешно пройдены**. Кроме того, мы видим отчет о **покрытии кода (coverage)** — он показывает, что наши тесты проверяют **100%** кода. Это значит, что ни одна строчка не осталась без внимания».

### Шаг 3: Показываем магию CI

**Что делать:**
1.  Откройте файл `.github/workflows/ci.yml`.

**Что говорить:**
«А теперь самое главное — автоматизация. Этот файл (`ci.yml`) — это инструкция для GitHub Actions. Здесь написано, что при каждом обновлении кода в репозитории нужно автоматически выполнить те же самые шаги, что я только что сделал вручную: установить зависимости и запустить тесты. Обратите внимание на `matrix`, мы даже можем запускать тесты сразу на нескольких версиях Python, чтобы убедиться в совместимости».

**Что говорить (заключение по заданию 1):**
«Таким образом, мы построили "систему безопасности": ни одно изменение не попадет в основную ветку, если оно ломает тесты. Это и есть **непрерывная интеграция** — постоянная проверка качества кода».

--- 

## Часть 2: Непрерывная доставка (CD) с Docker

**Цель:** Показать, как упаковать приложение в контейнер и автоматизировать его сборку.

### Шаг 1: Показываем веб-приложение

**Что делать:**
1.  Откройте папку `flask-docker-app`.
2.  Откройте файл `app.py`.

**Что говорить:**
«Переходим ко второму заданию. Здесь у нас простое веб-приложение, написанное на Flask. У него есть несколько API-адресов, например, для проверки "здоровья" приложения».

### Шаг 2: Объясняем, что такое Dockerfile

**Что делать:**
1.  Откройте файл `Dockerfile`.

**Что говорить:**
«Чтобы решить проблему "у меня работает, а на сервере нет", мы используем Docker. Этот `Dockerfile` — это как рецепт для сборки нашего приложения. Мы говорим: возьми чистый Python, скопируй наш код, установи зависимости и укажи, как его запускать. В результате мы получаем **контейнер** — изолированную среду, которая будет работать одинаково везде».

### Шаг 3: Демонстрируем работу приложения

**Что делать:**
1.  Откройте терминал в папке `flask-docker-app`.
2.  Выполните команду для запуска приложения (без Docker):
    ```bash
    python3 app.py
    ```
3.  В другом терминале или браузере проверьте, что оно работает, выполнив команду:
    ```bash
    curl http://localhost:5000/api/health
    ```

**Что говорить:**
«Сначала запустим приложение локально. Как видите, оно работает и отвечает, что статус "healthy". Но это на моей машине. Теперь давайте покажем, как Docker делает его переносимым».

*(Примечание: Если сборка Docker занимает много времени, можно просто показать `Dockerfile` и симуляцию вывода, как в отчете).* 

### Шаг 4: Показываем автоматизацию сборки

**Что делать:**
1.  Откройте файл `.github/workflows/docker-build.yml`.

**Что говорить:**
«Так же, как и в первом задании, я автоматизировал этот процесс. Этот workflow-файл описывает, как при каждом обновлении кода автоматически собирать новый Docker-образ, тестировать его и публиковать в хранилище (Docker Hub). Это и есть **непрерывная доставка**: у нас всегда есть готовый к развертыванию, протестированный артефакт».

--- 

## Часть 3: Повторно используемый CI-шаблон

**Цель:** Показать, как избежать дублирования кода и стандартизировать CI/CD процессы.

### Шаг 1: Показываем проблему

**Что делать:**
1.  Быстро откройте `ci.yml` из первого задания и `docker-build.yml` из второго.

**Что говорить:**
«Я выполнил два задания и заметил, что в моих CI/CD файлах много похожего, повторяющегося кода. Если у нас будет 10 или 100 проектов, поддерживать все это станет очень сложно. Это подводит нас к третьему заданию».

### Шаг 2: Показываем решение — шаблон

**Что делать:**
1.  Откройте папку `python-ci-template`.
2.  Откройте файл `.github/workflows/ci-template.yml`.

**Что говорить:**
«Решение — создать **универсальный CI-шаблон**. Я вынес всю логику — проверку стиля кода, запуск тестов, анализ безопасности — в один файл. Этот шаблон можно настраивать: выбирать версии Python, включать или отключать шаги».

### Шаг 3: Показываем, как легко его использовать

**Что делать:**
1.  Откройте файл `example-usage.yml`.

**Что говорить:**
«А теперь посмотрите, как легко его использовать. Вместо 150 строк кода, как раньше, теперь для настройки CI в новом проекте достаточно написать всего 5-10 строк. Мы просто говорим: "Используй вот этот шаблон". Это колоссальная экономия времени и сил».

### Шаг 4: Демонстрируем выгоду

**Что делать:**
1.  Откройте файл `COMPARISON.md`.

**Что говорить:**
«Чтобы наглядно показать преимущества, я составил сравнительную таблицу. **До стандартизации** настройка CI занимала часы, и в каждом проекте был свой "зоопарк" технологий. **После** — это занимает минуты, и все проекты следуют единому высокому стандарту качества. Это повышает надежность и упрощает поддержку».

--- 

### Общее заключение

**Что говорить:**
«Таким образом, в ходе этой работы я построил полный DevOps-цикл: от автоматической проверки качества кода до создания готового к развертыванию артефакта и, что самое важное, стандартизировал этот процесс с помощью повторно используемого шаблона. Это позволяет разрабатывать программное обеспечение быстрее, качественнее и с меньшими затратами».

«Спасибо за внимание! Готов ответить на ваши вопросы».
